'''
This script is used to do galaxy clustering analysis by angualr correlation function
and estimate mass of host halo through comparing bias we calculate and bias from simulation
'''


import os 
import test_1
import numpy as np
import halomod as hm
from scipy import integrate as ing
from scipy.optimize import curve_fit as cf
import matplotlib.pyplot as plt
import pdb


#read data
os.chdir('/home/wu/ASTRO/GCA/data/Flashlight_catalog/Images (5)')
ra_g,dec_g=np.hsplit(np.genfromtxt('LATcat5.txt',delimiter=','),2)
ra_r,dec_r=np.random.uniform(low=np.min(ra_g),high=np.max(ra_g),size=(1,40*len(ra_g)))[0],np.random.uniform(low=np.min(dec_g),high=np.max(dec_g),size=(1,40*len(dec_g)))[0]
ra_r,dec_r=ra_r.reshape(len(ra_r),1),dec_r.reshape(len(dec_r),1)
ra_gr=np.vstack((ra_g,ra_r));dec_gr=np.vstack((dec_g,dec_r))




#counts number of pairs of galaxy-galaxy random-random and galaxy-random
pairs_gg,bins_gg,min_gg,max_gg=test_1.c_pairs(ra_g,dec_g,51)
pairs_rr,bins_rr,min_rr,max_rr=test_1.cr_pairs(ra_r,dec_r,50,min_gg,max_gg)
pairs_gr,bins_gr,min_gr,max_gr=test_1.cr_pairs(ra_gr,dec_gr,50,min_gg,max_gg)
pairs_gr=pairs_gr-pairs_gg-pairs_rr
pairs_gg,pairs_rr,pairs_gr=pairs_gg/float(pairs_gg[-1]),pairs_rr/float(pairs_rr[-1]),pairs_gr/float(pairs_gr[-1])




#calculate angular correlation function through estimator prompted by Landy and Szalay 1993
omga_theta=(pairs_gg+pairs_rr-2*pairs_gr)/pairs_rr
index_badvalue=np.where(omga_theta<=0)
bins=(bins_gg+bins_rr+bins_gr)/3.0
bins,omga_theta,pairs_gg,pairs_rr,pairs_gr=np.delete(bins,index_badvalue),np.delete(omga_theta,index_badvalue),np.delete(pairs_gg,index_badvalue),np.delete(pairs_rr,index_badvalue),np.delete(pairs_gr,index_badvalue)
omga_theta=omga_theta+pairs_rr*omga_theta/np.sum(pairs_rr)




#estimate the parameter of fit function(A is the parameter)
def func0(r,A):
    return A*(r**-0.8)
A,pcov=cf(func0,bins,omga_theta);A=A[0]
A_std=np.sqrt(np.diag(pcov))
bins_fit=np.arange(np.min(bins),np.max(bins),(np.max(bins)-np.min(bins))/500.0)
omga_fit=func0(bins_fit,A)




#transform angular correlation function to spatial correlation function
c=299792458;det_z=0.027;H0=7e4;Hr=3.68;W0=0.3;z0=2.254;sigma_8_z=0.311839;gamma=1.8;sigma_H0=770
def func(z):
    return 1/((((1+z)**3)+(W0**-1)-1)**0.5)
inte=ing.fixed_quad(func,0,z0)
x=(c/H0)*(W0**-0.5)*inte[0]
P=(W0**0.5)*(((1+z0)**3)+(1/W0)-1)**0.5
r0=((c*A*det_z)/(H0*Hr*(x**-0.8)*P))**(1.0/1.8)




#calculate bias with correlation length
J=72/((3-gamma)*(4-gamma)*(6-gamma)*(2**gamma))
sigma_gal_8=np.sqrt(J*(r0*0.7/8)**1.8);b=sigma_gal_8/sigma_8_z
dA=A_std[0]/(gamma*A)
dH0=-sigma_H0/H0
f=func(z0)
dz=det_z*(((3*(1+z0)**2)/(2*gamma*(1.0/f)**2))-(1.0-gamma)*(1.0/f)/(gamma*inte[0]))
E_r0=np.sqrt((dA**2)+(dH0**2)+(dz**2))
sigma_r0=E_r0*r0
#pdb.set_trace()
print 'r0='+str(r0)
print 'b='+str(b)



#compare bias calculated above with bias generated by simulation and estimate the host halo mass
halo=hm.HaloModel(z=2.255,bias_model='ST99')
halo_mass=np.mean(halo.m[(halo.bias>b-0.01*b)&(halo.bias<b+0.01*b)])
print 'host halo mass='+str(halo_mass)
print halo.m[(halo.bias>b-0.01*b)&(halo.bias<b+0.01*b)]

import os
import pdb
import numpy as np
from astropy import units as u,constants as const
from astropy.cosmology import FlatLambdaCDM as FlatCDM


def d_pairs(x,y):
    '''
    Thsis function is used to obtain 2-d two-point correlation function
    (x,y) is the coordinate of each galaxy
    '''
    
    
    #this part is used to calculate distance between every galaxy pairs in data
    x,y=np.array(x),np.array(y)
    pointset=np.c_[x,y]
    distanceset=np.array([])
    while len(pointset)>1:
        for i in range(1,len(pointset)):
            l=np.linalg.norm(pointset[0]-pointset[i])
            distanceset=np.append(distanceset,l)
        pointset=np.delete(pointset,0,0)
    
    #this part is used to statistic counts in each bin
    counts,bins=np.histogram(distanceset,bins='auto')
    return counts,bins


def r_pairs(x,y,bins):
    '''
    This function is the same with d_pairs but need one more parameter
    bins: we need this parameter because we must calculate dd pairs,rr_pairs and dr_pairs in the same bin
    '''
    x,y=np.array(x),np.array(y)
    pointset=np.c_[x,y]
    distanceset=np.array([])
    while len(pointset)>1:
        for i in range(1,len(pointset)):
            l=np.linalg.norm(pointset[0]-pointset[i])
            distanceset=np.append(distanceset,l)
        pointset=np.delete(pointset,0,0)
    
    counts,bins=np.histogram(distanceset,bins)
    
    return counts,bins


def ACF(files,z0):
    '''
    This function is used to do galaxy clustering analysis by angualr correlation function
    and estimate mass of host halo through comparing bias we calculate and bias from simulation
    '''
    import test_1
    import halomod as hm
    from scipy import integrate as ing
    from scipy.optimize import curve_fit as cf
    
    
    #read data
    ra_g,dec_g=np.hsplit(np.genfromtxt(files,delimiter=','),2)
    ra_r,dec_r=np.random.uniform(low=np.min(ra_g),high=np.max(ra_g),size=(1,40*len(ra_g)))[0],np.random.uniform(low=np.min(dec_g),high=np.max(dec_g),size=(1,40*len(dec_g)))[0]
    ra_r,dec_r=ra_r.reshape(len(ra_r),1),dec_r.reshape(len(dec_r),1)
    ra_gr=np.vstack((ra_g,ra_r));dec_gr=np.vstack((dec_g,dec_r))
    
    
    #counts number of pairs of galaxy-galaxy random-random and galaxy-random
    pairs_gg,bins_gg,min_gg,max_gg=test_1.c_pairs(ra_g,dec_g,51)
    pairs_rr,bins_rr,min_rr,max_rr=test_1.cr_pairs(ra_r,dec_r,50,min_gg,max_gg)
    pairs_gr,bins_gr,min_gr,max_gr=test_1.cr_pairs(ra_gr,dec_gr,50,min_gg,max_gg)
    pairs_gr=pairs_gr-pairs_gg-pairs_rr
    pairs_gg,pairs_rr,pairs_gr=pairs_gg/float(pairs_gg[-1]),pairs_rr/float(pairs_rr[-1]),pairs_gr/float(pairs_gr[-1])
    
    
    #calculate angular correlation function through estimator prompted by Landy and Szalay 1993
    omga_theta=(pairs_gg+pairs_rr-2*pairs_gr)/pairs_rr
    index_badvalue=np.where(omga_theta<=0)
    bins=(bins_gg+bins_rr+bins_gr)/3.0
    bins,omga_theta,pairs_gg,pairs_rr,pairs_gr=np.delete(bins,index_badvalue),np.delete(omga_theta,index_badvalue),np.delete(pairs_gg,index_badvalue),np.delete(pairs_rr,index_badvalue),np.delete(pairs_gr,index_badvalue)
    omga_theta=omga_theta+pairs_rr*omga_theta/np.sum(pairs_rr)
    
    
    #estimate the parameter of fit function(A is the parameter)
    def func0(r,A):
        return A*(r**-0.8)
    A,pcov=cf(func0,bins,omga_theta);A=A[0]
    A_std=np.sqrt(np.diag(pcov))
    bins_fit=np.arange(np.min(bins),np.max(bins),(np.max(bins)-np.min(bins))/500.0)
    omga_fit=func0(bins_fit,A)
    
    
    #transform angular correlation function to spatial correlation function
    c=299792458;det_z=0.027;H0=7e4;Hr=3.68;W0=0.3;sigma_8_z=0.311839;gamma=1.8;sigma_H0=770
    def func(z):
        return 1/((((1+z)**3)+(W0**-1)-1)**0.5)
    inte=ing.fixed_quad(func,0,z0)
    x=(c/H0)*(W0**-0.5)*inte[0]
    P=(W0**0.5)*(((1+z0)**3)+(1/W0)-1)**0.5
    r0=((c*A*det_z)/(H0*Hr*(x**-0.8)*P))**(1.0/1.8)
    
    
    #calculate bias with correlation length
    J=72/((3-gamma)*(4-gamma)*(6-gamma)*(2**gamma))
    sigma_gal_8=np.sqrt(J*(r0*0.7/8)**1.8);b=sigma_gal_8/sigma_8_z
    dA=A_std[0]/(gamma*A)
    dH0=-sigma_H0/H0
    f=func(z0)
    dz=det_z*(((3*(1+z0)**2)/(2*gamma*(1.0/f)**2))-(1.0-gamma)*(1.0/f)/(gamma*inte[0]))
    E_r0=np.sqrt((dA**2)+(dH0**2)+(dz**2))
    sigma_r0=E_r0*r0
    
    
    #compare bias calculated above with bias generated by simulation and estimate the host halo mass
    halo=hm.HaloModel(z=z0,bias_model='ST99')
    halo_mass=np.mean(halo.m[(halo.bias>b-0.01*b)&(halo.bias<b+0.01*b)])
    

    return halo_mass,b


def LF(file_name,z,deta_z,sigma,deta_apha,deta_sigma,lamda_NB,deta_lamda_NB):
    '''
    This function is used to obtain the galaxy luminosity function
    file_name: the file's name(include path) which contains data 
    z: the redshift of the target
    deta_z: length of redshift interval
    sigma: DEC of the target
    deta_apha,deta_sigma: length of angular interval
    lamda_NB: effective wavelength of the narrowband filter
    deta_lamda_NB: FWHM of the emission line

    we use z deta_z sigma,deta_sigma,deta_apha to calculate the volume of the field which is used to calculate the number density
    lamda_NB and deta_lamda_NB are used to calculate the emission's flux

    '''


    #define some cosntant and convert some parameter to proper units
    cosmo=FlatCDM(H0=68*u.km/u.s/u.Mpc,Tcmb0=2.725*u.K,Om0=0.3)
    c=const.c;dl=cosmo.luminosity_distance(z);dl2=cosmo.luminosity_distance(z+deta_z);lamda_NB=lamda_NB*u.AA;deta_lamda_NB=deta_lamda_NB*u.AA;sigma=(sigma*u.deg).to(u.rad);deta_apha=(deta_apha*u.deg).to(u.rad);deta_sigma=(deta_sigma*u.deg).to(u.rad);deta_DL=dl2-dl
    deta_v_NB=(c/lamda_NB**2)*deta_lamda_NB
    
    
    #read the file which contains the magnitude data
    data=np.genfromtxt(file_name,delimiter=',')
    m_NB=data[:,0];m_g=data[:,1]
    

    #calculate the luminosity of each galaxy,the equation you can found here:
    #https://github.com/zsw6666/test/blob/master/Equation_F_LF.jpg
    F_Lya=(3631*u.Jy)*deta_v_NB*((10**(m_NB/-2.5))-(10**(m_g/-2.5)))
    L_Lya=(F_Lya*4*np.pi*dl**2).to(u.erg/u.s)
    
    
    #statistic counts in each bin and convert the counts to number density
    [counts,bins]=np.histogram(L_Lya,bins='auto') 
    Vmax=(dl**2)*np.cos(sigma)*deta_apha*deta_sigma*deta_DL
    deta_L=bins[1]-bins[0]
    counts=counts/Vmax 
    bins=np.delete(bins,np.append(np.where(counts==0.),0))*(u.erg/u.s)
    counts=np.delete(counts,np.where(counts==0.))

    
    errorbar=np.sqrt(counts)*(1/np.sqrt(Vmax))
    
    return bins.value,counts.value,errorbar.value,deta_L

def SCF(L,Le,apha,phie):
    '''
    Schechter luminosity function which is used to fit data
    Le,apha,phie: the parameter(phie is the normalization)
    L: the variable
    '''

    phi=(1/Le)*phie*((L/Le)**apha)*np.exp(-L/Le)
    return phi


#Example
if __name__=='__main__':
    import pdb
    import matplotlib.pyplot as plt
    L_lya,n,err,deta_L=LF('/home/wu/ASTRO/GCA/data/Flashlight_catalog/Images (5)/LAE-Mab5.txt',2.255,0.027,0.90915,0.009155,0.0095589,3955,32.7)
    index=[len(L_lya)-1,len(L_lya)-2] 
    L_lya=np.delete(L_lya,index)
    n=np.delete(n,index)
    err=np.delete(err,index) 
    L_fit=np.arange(min(L_lya),max(L_lya)+0.5*max(L_lya),(max(L_lya)-min(L_lya))/500.0)
    Le=10**42.33;apha=-1.65;phie=10**(-2.86)
    N_fit=SCF(L_fit,Le,apha,phie)*deta_L
    #pdb.set_trace()
    plt.figure(1)
    ax=plt.gca()
    ax.set_yscale('log')
    ax.set_xscale('log')
    plt.title('Luminosity Function')
    plt.xlabel('Luminosity erg/s')
    plt.ylabel('n Mpc-3')
    plt.xlim(min(L_lya),max(L_lya))
    plt.ylim(min(N_fit),max(n))
    plt.errorbar(L_lya,n,fmt='o',yerr=err)
    plt.plot(L_fit,N_fit,c='r')
    plt.show()
